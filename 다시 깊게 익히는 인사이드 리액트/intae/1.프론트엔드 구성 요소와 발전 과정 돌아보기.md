### 1. 프론트엔드의 구성 요소와 발전 과정을 돌아봐야 하는 이유

프론트엔드 개발의 역사를 공부하는 것은 단순하게 과거의 사실을 알고 나열하는 것이 아니라 기술들의 근본적인 왜?를 이해하는 것입니다. 단순히 문법을 암기하는 수준을 넘어 기술의 본질을 꿰뚫고 제대로 활용하는 개발자로 성장하는 밑거름이 됩니다. 각 기술이 어떤 역사적 맥락에서 어떤 문제를 해결하기 위해 등장했는지 어떤 장단을 가지고 있는지 합리적인 의사결정을 내릴 수 있다면 문제 해결 능력을 갖춘 전문가로 성장하기 위한 단단한 발판이 될 것입니다.

### 2. 초창기 프론트엔드 간단 요약

기본적으로 웹은 html, css, js 로 구성되지만 css, js가 맨처음부터 있던 것은 아니고, 모든 디자인이 다 html 태그안에 들어가 있었습니다. 그리고 대부분의 로직은 전부 서버에서 처리됐고, 2000년대가 되어서야 HTML을 트리구조로 표현하여 동적으로 조작할 수 있게 되었습니다.

그래서 초창기 웹페이지는 단일 페이지가 아닌 여러 페이지로 이루어져, 새로운 ui를 보여줘야 할 때 마다 웹 서버에 요청해야 했습니다. 그것을 MPA(Multi Page Application) 이라고 부릅니다.

UI 변경이 있을 때 마다 새로고침을 해야해서 유저 경험이 많이 저하됐고, 그것을 극복하고자 여러 페이지에 사용할 코드 조각을 공유하기로 했고, JS 모듈을 만들고 공유하기로 했으나 공통으로 사용하다보면 의존성이 생겨서 태그 삽입 순서가 굉장히 중요해지고 공수가 많이 들었습니다.

### 3. 번들러의 등장

모듈의 의존성 문제는 번들러라는 도구로 해결하게 되는데, 번들러는 원하는 라이브러리만 요청하면 의존성을 알아서 해결하는 도구입니다. 의존성 순서 걱정 없이 개발 환경을 구성할 수 있게 도움을 줬습니다.

또한 배포 단계에서 필요 없는 코드를 제거하여 번들의 크기를 줄이는 트리 쉐이킹 기능을 제공하여 편의를 제공했습니다.

### 4. 패키지 매니저의 도입

초창기 웹 개발에서 외부 라이브러리를 사용하려면 각 라이브러리 웹 사이트를 방문해 js 파일을 내려받고 특정 폴더에 저장해야 했습니다. 저도 jquery 나 bootstrap의 zip 파일을 풀었던 기억들이 나는데요 각 라이브러리를 더 쉽게 사용할 수 있게 하는 NPM 이 등장 하였습니다. package.json 안에 있는 필요한 라이브러리들의 청사진이 있으면 npm install 과 같은 커맨드만 입력했을 때 동일한 개발 환경을 쉽게 셋팅할 수 있습니다.

### 5. 명령형 프로그래밍 vs 선언형 프로그래밍

백 / 프론트의 영역이 분리되기 시작하면서 단순 개발 환경 구성 뿐만 아니라 전문 영역 안에서 더욱 많고 복잡한 일을 할 수 있게 되었습니다. 기존에는 DOM 하나를 일일이 집어 변경하는 것이 아니라 코드 조각으로 미리 선언해놓은 모습 그대로 화면에 표시하는 기술을 만들게 되었습니다.

| 구분                | 명령형 (Imperative)                        | 선언형 (Declarative)                                 |
| ------------------- | ------------------------------------------ | ---------------------------------------------------- |
| **핵심 개념**       | **어떻게(How)** 할 것인지를 단계별로 기술  | 무엇(What)을 할 것인지를 기술                        |
| **관심사**          | 절차와 흐름 제어                           | 결과와 의도                                          |
| **상태 관리**       | 변수를 직접 변경하며 상태를 추적           | 상태 변환을 선언적으로 표현                          |
| **제어 흐름**       | `for`, `while`, `if/else` 등 직접 제어     | `map`, `filter`, `reduce` 등 추상화된 연산           |
| **가독성**          | 흐름을 따라가며 이해해야 함                | 의도가 코드에 바로 드러남                            |
| **대표 패러다임**   | 절차적 프로그래밍, OOP 일부                | 함수형 프로그래밍, SQL, HTML/CSS                     |
| **프론트엔드 예시** | DOM을 직접 조작 (`document.createElement`) | React JSX로 UI 상태를 선언 (`<List items={data} />`) |
| **부수 효과**       | 부수 효과가 코드 전반에 산재하기 쉬움      | 부수 효과를 격리하고 최소화하려 함                   |
| **디버깅**          | 실행 순서를 추적하며 디버깅                | 입력→출력 관계로 디버깅                              |
| **재사용성**        | 특정 흐름에 종속되어 재사용 어려움         | 조합과 합성이 용이                                   |
