숙련된 프론트엔드 개발자라면 디자인 문서를 읽고 커다란 웹페이지를 작은 조각 Ui 컴포넌트로 나눌 수 있어야합니다.

### 1. UI 컴포넌트의 위상?

현대 프론트엔드 개발에서 컴포넌트는 너무나도 당연하게 사용하고 있지만 라이브러리나 프레임워크 중심적 사고에 갇히지 않게 개념 자체의 위상을 되짚어 볼 필요가 있습니다.

1. 프레임워크로 부터 독립과 개념적인 이해를 위해서 : 리액트의 JSX는 UI 컴포넌트를 만들기 위한 도구일 뿐 컴포넌트의 본질이 아닙니다. 컴포넌터의 진짜 본질은 추상화, 인터페이스 설계, 캡슐화라는 원칙에 있습니다.
2. 더 나은 추상화 설계 능력을 기르기 위해 : 훌륭한 컴포넌트는 그 자체로 잘 만들어진 제품 같습니다. 내부의 복잡한 구현을 숨기고, 예측 가능하게 동작해야합니다.
3. 웹 표준의 흐름을 자연스럽게 이해하기 위해 : UI 컴포넌트의 중요성이 커지면서, 브라우저 스스로가 컴포넌트를 네이티브로 지원하려는 움직이 생겼습니다.

우리는 어떤 프레임워크나 라이브러리에 종속되는 것이 아니라 컴포넌트의 설계자로 거듭나야합니다.

### 2. 프론트엔드 개발에서 UI 컴포넌트의 위상

구현된 UI 를 가장 먼저 사용하는 사람은 프론트엔드 개발자이기 때문에 시안의 완성도가 높을지라도 예상과 다른 유저경험을 제공할 수 있습니다. 그렇게 때문에 시안에 정의된 개별적인 시각 요소의 규격들을 엄격하게 정의하고 재활용 할 수 있어야합니다.

또한 프론트엔드 개발자는 리액트, 뷰와 같은 프레임워크, 라이브러리를 사용하지 않고도, 프론트엔드를 개발 할 수 있는 능력을 길러야합니다.

저만 생각해도 state와 props가 왜 존재하고 필요한지 고민하는 기회를 얻지 못하고 있습니다.

추상화가 된 컴포넌트가 제공하는 인터페이스에 익숙해져 있기 때문인데요, 리액트의 도움을 받지 않고도 컴포넌트가 어떻게 구성되는지 알아야합니다.

### 3. 자바스크립트 컴포넌트 vs 웹 컴포넌트

| 비교 항목             | 웹 컴포넌트 (Web Components)                                                                       | 바닐라 자바스크립트 (Vanilla JS)                                    |
| --------------------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| **핵심 개념**         | Custom Elements, Shadow DOM, HTML Templates 등 브라우저 네이티브 API를 활용한 재사용 가능 컴포넌트 | 프레임워크 없이 순수 JavaScript만으로 DOM을 직접 조작               |
| **캡슐화**            | Shadow DOM을 통해 스타일과 마크업이 완전히 격리됨                                                  | 캡슐화 메커니즘 없음. 전역 CSS와 DOM이 충돌할 수 있음               |
| **재사용성**          | 커스텀 태그(`<my-button>`)로 어디서든 재사용 가능. 프레임워크에 무관하게 동작                      | 함수나 모듈로 재사용 가능하나, 표준화된 컴포넌트 인터페이스 없음    |
| **스타일 관리**       | Shadow DOM 내부 스타일은 외부와 완전 분리. `::part()`, CSS 변수로 외부 커스터마이징                | 전역 CSS 적용. BEM, CSS Modules 등 네이밍 컨벤션으로 충돌 회피 필요 |
| **라이프사이클**      | `connectedCallback`, `disconnectedCallback`, `attributeChangedCallback` 등 표준 라이프사이클 제공  | 직접 이벤트 리스너 등록/해제를 수동 관리해야 함                     |
| **상태 관리**         | 내부 프로퍼티와 `attributeChangedCallback`으로 반응형 업데이트 가능                                | 상태 변경 시 DOM 업데이트를 직접 구현해야 함                        |
| **의존성**            | 없음. 브라우저 네이티브 API                                                                        | 없음. 순수 JavaScript                                               |
| **프레임워크 호환성** | React, Vue, Angular 등 모든 프레임워크에서 사용 가능                                               | 프레임워크와 무관하게 동작하지만, 통합 시 별도 래퍼 필요            |
| **브라우저 지원**     | 모든 모던 브라우저 지원. IE는 폴리필 필요                                                          | 모든 브라우저에서 동작 (ES5 기준)                                   |
| **학습 곡선**         | Shadow DOM, 슬롯, 커스텀 레지스트리 등 새로운 개념 학습 필요                                       | JavaScript 기본 지식만으로 시작 가능                                |
| **번들 크기**         | 추가 라이브러리 불필요. 네이티브 API이므로 번들에 포함되지 않음                                    | 최소 번들. 사용한 코드만 포함                                       |
| **디버깅**            | Shadow DOM 내부 디버깅이 상대적으로 복잡. DevTools 지원은 점차 개선 중                             | DevTools로 직관적 디버깅 가능                                       |
| **SEO**               | Shadow DOM 내부 콘텐츠는 크롤러가 접근하기 어려울 수 있음. Declarative Shadow DOM으로 개선 중      | DOM에 직접 렌더링하므로 크롤러 접근 용이                            |
| **테스팅**            | 표준 DOM API로 테스트 가능. Shadow DOM 내부 접근 시 `shadowRoot` 활용                              | 일반적인 DOM 테스트 방식으로 간단히 테스트 가능                     |
| **코드 구조**         | 클래스 기반으로 구조화된 컴포넌트 패턴 강제                                                        | 자유로운 구조. 컨벤션에 따라 품질 편차가 큼                         |
| **커뮤니티/생태계**   | Lit, Stencil, FAST 등 헬퍼 라이브러리 존재. 생태계는 상대적으로 작음                               | 가장 넓은 생태계. 모든 JavaScript 라이브러리 활용 가능              |

---
