# 동적 프로그래밍

최적의 부분 문제들을 해결한 다음 이에 대한 결과를 메모리에 저장해 동일한 문제를 해결해야 하는 경우에 언제든지 이미 해결된 문제의 결과에 접근할 수 있도록 한다.

## 동적 프로그래밍의 규칙

동적 프로그래밍은 재계산을 피하기 위해 이미 계산된 값들을 저장하고 해당 값들을 사용하는 방법이다. 이 방법은 중복 부분 문제들이 존재하고 최적 부분 구조가 존재하는 문제에만 적용할 수 있다.

### 중복 부분 문제?

동일한 부분 문제에 대한 해결책이 여러 번 사용되는 경우에 동적 프로그래밍을 사용하며, 동적 프로그래밍은 보통 부분 문제의 해결책을 해시 테이블과 배열, 행렬에 저장하며 이러한 방식을 메모이제이션이라고 부른다.

### 최적 부분 구조

어떤 문제의 최적 해결책을 해당 문제의 부분 문제들의 최적 해결책들을 사용해 찾을 수 있을 때 이를 최적 부분 구조라한다.

예를 들어 최단 경로 찾기 알고리즘에는 최적 부분 구조들이 있다. 차를 타고 도시들을 여행하기 위한 최단 경로를 찾는다고 가정해보자. LA에서 밴쿠버까지의 최단 경로가 샌프란시스코와 시애틀을 거치는 경우, 샌프란시스코에서 밴쿠버까지의 최단 경로 역시 시애틀을 거칠 것이다.

## 동적 프로그래밍 접근방법

### 1. Top-Down (Memoization)

핵심 개념
"큰 문제부터 시작해서 작은 문제로 쪼개가며 재귀 호출 + 결과를 메모에 저장"특징

- 재귀 함수 사용
- 필요한 부분 문제만 계산 (Lazy Evaluation)
- 직관적이고 이해하기 쉬움
- 콜스택 사용 (깊이가 깊으면 스택 오버플로우 가능)

### 2. Bottom-Up (타뷸레이션, Tabulation)핵심 개념

"가장 작은 문제부터 시작해서 테이블을 채워가며 큰 문제로 올라감"특징

- 반복문 사용 (for, while)
- 모든 부분 문제를 순서대로 계산
- 재귀 없어서 스택 오버플로우 걱정 없음
- 일반적으로 Top-Down보다 빠름
- 공간 최적화 가능

## 대표적인 동적 프로그래밍 예

### 1️⃣ 배낭 문제 알고리즘

배낭 문제는 다음과 같다. 무게와 가치를 지니는 n개의 항목이 주어졌을 때 최대 w의 무게를 담을 수 있는 배낭에 대항 항목들을 집어넣어 배낭에 담긴 항목들의 가치의 합이 최대가 되도록 한다.

### 최적 부분 구조

배열의 각 항목은 다음 두 가지 중 하나에 해당한다.

- 항목이 최적 부분집합에 포함된다.
- 항목이 최적 부분집합에 포함되지 않는다.

따라서 n개의 항목으로부터 얻을 수 있는 최대 가치는 다음 중 하나다.

1. (n번째 항목이 제외되는 경우) : n-1 개의 항목에서 얻은 최대 가치
2. (n번째 항목을 포함하는 경우) : n-1 개의 항목에서 얻은 최대 가치 + n번째 항목의 가치(n번째 항목의 무게가 W보다 작은 경우에만 가능하다)

```javascript
function knapsackNaive(index, weights, values, target) {
  var result = 0;

  if (index <= -1 || target <= 0) {
    result = 0;
  } else if (weights[index] > target) {
    result = knapsackNaive(index - 1, weights, values, target);
  } else {
    // 첫 번째 경우:
    var current = knapsackNaive(index - 1, weights, values, target);
    // 두 번째 경우:
    var currentPlusOther =
      values[index] +
      knapsackNaive(index - 1, weights, values, target - weights[index]);

    result = Math.max(current, currentPlusOther);
  }

  return result;
}

var weights = [1, 2, 4, 2, 5],
  values = [5, 3, 5, 3, 2],
  target = 10;

knapsackNaive(4, weights, values, target);
```

### 동적프로그래밍을 적용한 경우

이미 계산된 재귀 호출의 경우에 저장된 결과를 사용한다.

```javascript
function knapsackDP(index, weights, values, target, matrixDP) {
  var result = 0;

  // DP part - 메모이제이션 체크
  if (matrixDP[index + "-" + target]) {
    return matrixDP[index + "-" + target];
  }

  // 베이스 케이스
  if (index <= -1 || target <= 0) {
    result = 0;
  } else if (weights[index] > target) {
    // 현재 아이템이 너무 무거움 - 건너뛰기
    result = knapsackDP(index - 1, weights, values, target, matrixDP);
  } else {
    // 두 가지 경우 비교
    var current = knapsackDP(index - 1, weights, values, target, matrixDP),
      currentPlusOther =
        values[index] +
        knapsackDP(
          index - 1,
          weights,
          values,
          target - weights[index],
          matrixDP
        );

    result = Math.max(current, currentPlusOther);
  }

  // 결과를 메모에 저장
  matrixDP[index + "-" + target] = result;

  return result;
}
```

### 2️⃣ 최장 공통 부분 수열 알고리즘

두 개의 수열이 있을 때 가장 긴 공통 부분 수열의 길이를 찾는다. 이때 부분 수열 내 항목들이 연속일 필요는 없고 순서만 맞으면 된다. 예를 들어 sam, sie, aie 와 같은 부분 수열은 sammie의 부분 수열이다. 문자열의 길이가 n일 때 가능한 부분 수열 조합의 개수는 2^n 개다.

단순한 접근법

```
1. 만약 두 수열의 마지막 글자가 일치한다면 예를 들어 (str1[m-1] == str2[n-1])

    result = 1 + LCS(X[0:m-2], Y[0:n-2])

2. 만약 두 수열의 마지막 글자가 일치하지 않는다면 예를 들어 (str1[m-1] == str2[n-1])

     result = 1 + LCS(X[0:m-2], Y[0:n-2])
```

### 재귀 방식

```javascript
function LCSNaive(str1, str2, str1Length, str2Length) {
  if (str1Length == 0 || str2Length == 0) {
    return 0;
  }

  if (str1[str1Length - 1] == str2[str2Length - 1]) {
    return 1 + LCSNaive(str1, str2, str1Length - 1, str2Length - 1);
  } else {
    return Math.max(
      LCSNaive(str1, str2, str1Length, str2Length - 1),
      LCSNaive(str1, str2, str1Length - 1, str2Length)
    );
  }
}

function LCSNaiveWrapper(str1, str2) {
  return LCSNaive(str1, str2, str1.length, str2.length);
}

LCSNaiveWrapper("AGGTAB", "GXTXAYB"); // 4
```

### 동적프로그래밍 접근

```javascript
function longestCommonSequenceLength(str1, str2) {
  var matrix = Array(str1.length + 1).fill(Array(str2.length + 1).fill(0)),
    rowLength = str1.length + 1,
    colLength = str2.length + 1,
    max = 0;

  for (var row = 1; row < rowLength; row++) {
    for (var col = 1; col < colLength; col++) {
      var str1Char = str1.charAt(row - 1),
        str2Char = str2.charAt(col - 1);

      if (str1Char == str2Char) {
        matrix[row][col] = matrix[row - 1][col - 1] + 1;
        max = Math.max(matrix[row][col], max);
      }
    }
  }

  return max;
}
```

## 3️⃣ 동전 교환 알고리즘

동전의 금액 종류가 S={S1, S2, ... Sm}으로 M개이고 각 금액의 동전이 무한 개로 제공 될 수 있다고 할 때, 금액 n을 동전으로 교환하기 위한 동전의 조합은 몇 개나 될까? 이 떄 동전의 순서는 무시한다.

### 최적 부분 구조

1. M번째 동전이 포함되지 않는 해결책
2. M번째 동전이 최소 한 개는 포함되는 해결책

### 재귀방식

```javascript
// coinArr을 더해 원하는 값에 금액을 만들 수 있는 방법의 수를 반환한다.
// coinArr의 인덱스는 [0,...,numCoins]와 같다.
function countCoinWays(coinArr, numCoins, coinValue) {
  if (coinValue == 0) {
    // 값이 0이 도달한 경우 유일한 해결책은
    // 어떤 동전도 포함하지 않는 것이다.
    return 1;
  }

  if (coinValue < 0 || (numCoins <= 0 && coinValue >= 1)) {
    // 값이 0보다 작다는 것은 해결책이 없다는 의미이다.
    // 남은 동전이 없는데 coinValue가 남았어도 해결책이 없다는 의미이다.
    return 0;
  }

  //
  return (
    countCoinWays(coinArr, numCoins - 1, coinValue) +
    countCoinWays(coinArr, numCoins, coinValue - coinArr[numCoins - 1])
  );
}

function countCoinWaysWrapper(coinArr, coinValue) {
  return countCoinWays(coinArr, coinArr.length, coinValue);
}

result = countCoinWaysWrapper([1, 2, 3], 4);
```

### 동적프로그래밍 방식

```javascript
function countCoinWaysDP(coinArr, numCoins, coinValue) {
  // 행렬을 생성한다.
  var dpMatrix = [];

  for (var i = 0; i <= coinValue; i++) {
    dpMatrix[i] = [];
    for (var j = 0; j < numCoins; j++) {
      dpMatrix[i][j] = undefined;
    }
  }

  for (var i = 0; i < numCoins; i++) {
    dpMatrix[0][i] = 1;
  }

  for (var i = 1; i < coinValue + 1; i++) {
    for (var j = 0; j < numCoins; j++) {
      var temp1 = 0,
        temp2 = 0;

      if (i - coinArr[j] >= 0) {
        // coinArr[j]를 포함하는 해결책
        temp1 = dpMatrix[i - coinArr[j]][j];
      }

      if (j >= 1) {
        // coinArr[j]를 포함하지 않는 해결책
        temp2 = dpMatrix[i][j - 1];
      }

      dpMatrix[i][j] = temp1 + temp2;
    }
  }

  return dpMatrix[coinValue][numCoins - 1];
}

function countCoinWaysDPWrapper(coinArr, coinValue) {
  return countCoinWaysDP(coinArr, coinArr.length, coinValue);
}

countCoinWaysDPWrapper([1, 2, 3], 4);
```

## 4️⃣ 레벤슈타인 거리 알고리즘

길이 m인 문자열 str1과 길이n인 문자열 str2가 주어졌을 때 str1을 str2로 변환하기 위한 최소 편집 횟수는 무엇인가?
유효한 연산은 다음과 같다

- 삽입
- 제거
- 교환

### 최적 부분 구조

문자열 str1과 문자열 str2의 각 문자가 한 번에 하나씩 처리된다면 다음의 경우가 가능하다.

1. 문자가 동일하다 : 아무것도 하지 않는다.
2. 문자가 다르다 : 재귀적으로 다음 경우를 고려한다.

- 삽입 : m과 n-1
- 제거 : m-1 과 n
- 교환 : m-1 과 n-1

### 재귀사용

```javascript
function editDistanceRecursive(str1, str2, length1, length2) {
  // str1이 비었다. 유일한 선택 사항은 str2의 모든 문자를 삽입하는 것이다.

  if (length1 == 0) {
    return length2;
  }

  // str2가 비었다. 유일한 선택 사항은 str1의 모든 문자를 삽입하는 것이다.
  if (length2 == 0) {
    return length1;
  }

  // 마지막 문자가 동일하다.
  // 마지막 문자를 무시하고 나머지로 센다.
  if (str1[length1 - 1] == str2[length2 - 1]) {
    return editDistanceRecursive(str1, str2, length1 - 1, length2 - 1);
  }

  // 마지막 문자가 동일하지 않다.
  // 삽입, 제거, 교환 세 가지 연산이 가능하다.
  return (
    1 +
    Math.min(
      // 삽입
      editDistanceRecursive(str1, str2, length1, length2 - 1),
      // 제거
      editDistanceRecursive(str1, str2, length1 - 1, length2),
      // 교환
      editDistanceRecursive(str1, str2, length1 - 1, length2 - 1)
    )
  );
}

function editDistanceRecursiveWrapper(str1, str2) {
  return editDistanceRecursive(str1, str2, str1.length, str2.length);
}

editDistanceRecursiveWrapper("sammie", "bae");
```

### 동적프로그래밍 사용

```javascript
function editDistanceDP(str1, str2, length1, length2) {
  // 행렬을 생성한다.
  var dpMatrix = [];
  for (var i = 0; i < length1 + 1; i++) {
    dpMatrix[i] = [];
    for (var j = 0; j < length2 + 1; j++) {
      dpMatrix[i][j] = undefined;
    }
  }

  for (var i = 0; i < length1 + 1; i++) {
    for (var j = 0; j < length2 + 1; j++) {
      // 첫 번째 문자열 str1이 빈 경우
      // str2의 모든 문자를 삽입해야 한다.
      if (i == 0) {
        dpMatrix[i][j] = j;
      } else if (j == 0) {
        dpMatrix[i][j] = i;
      } else if (str1[i - 1] == str2[j - 1]) {
        // 동일한 경우 추가적인 비용이 없다.
        dpMatrix[i][j] = dpMatrix[i - 1][j - 1];
      } else {
        var insertCost = dpMatrix[i][j - 1],
          removeCost = dpMatrix[i - 1][j],
          replaceCost = dpMatrix[i - 1][j - 1];

        dpMatrix[i][j] = 1 + Math.min(insertCost, removeCost, replaceCost);
      }
    }
  }

  return dpMatrix[length1][length2];
}

function editDistanceDPWrapper(str1, str2) {
  return editDistanceDP(str1, str2, str1.length, str2.length);
}

editDistanceDPWrapper("sammie", "bae");
```

## 예시 문제

[줄 서는 방법 / 배낭 알고리즘] : https://school.programmers.co.kr/learn/courses/30/lessons/12936

[연속 부분 수열 합의 개수] : https://school.programmers.co.kr/learn/courses/30/lessons/131701
