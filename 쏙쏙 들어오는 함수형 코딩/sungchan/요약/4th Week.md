
## CHAPTER 8
# 계층형 설계 (Layered Design) 요점 정리

## 핵심 개념

**계층형 설계**는 바로 아래 계층의 함수로 현재 계층의 함수를 만드는 방법으로, 코드를 추상화 계층으로 구성하여 각 계층을 볼 때 다른 계층의 구체적인 내용을 몰라도 되도록 합니다.

## 계층형 설계의 장점

- **높은 가독성**: 코드를 이해하기 쉬워집니다
- **테스트 용이성**: 각 계층별로 독립적인 테스트 가능
- **유지보수 용이성**: 변경 사항이 다른 계층에 미치는 영향 최소화
- **재사용성**: 일반적인 함수일수록 더 많은 곳에서 재사용 가능

## 계층형 설계의 4가지 주요 패턴

### 1. 직접 구현 패턴 (Direct Implementation)

- **핵심**: 함수는 한 단계의 구체화 수준에 관한 문제만 해결
- **특징**: 모든 화살표(함수 호출)가 같은 길이를 가져야 함
- **목적**: 비슷한 추상화 계층의 함수만 호출하여 코드의 복잡성 감소

### 2. 추상화 벽 패턴

- 인터페이스를 통해 높은 차원의 사고 가능
- 두뇌 용량의 한계 극복

### 3. 작은 인터페이스 패턴

- 중요한 인터페이스는 작고 강력한 동작으로 구성

### 4. 편리한 계층 패턴

- 개발자 요구사항과 비즈니스 문제를 동시에 만족
- 더 빠르고 고품질의 소프트웨어 제공

## 3단계 줌 레벨

1. **전역 줌 레벨**: 계층 간 상호 관계 파악
2. **계층 줌 레벨**: 한 계층과 바로 아래 계층 관계 분석
3. **함수 줌 레벨**: 함수 하나와 직접 연결된 함수들 분석

## 호출 그래프의 중요성

- 함수 간의 의존성과 추상화 수준을 시각화
- 직접 구현 패턴 적용 여부 확인 가능
- 화살표 길이가 다양하면 직접 구현되지 않은 신호

---

# 퀴즈

## 퀴즈 1: 개념 이해

**계층형 설계에서 "직접 구현 패턴"이란 무엇이며, 이 패턴을 올바르게 적용했을 때 호출 그래프에서 나타나는 특징은 무엇인가요?**

<details> <summary>답안 보기</summary>

**직접 구현 패턴**은 함수가 한 단계의 구체화 수준에 관한 문제만 해결하도록 하는 패턴입니다.

올바르게 적용되었을 때 호출 그래프의 특징:

- 모든 화살표(함수 호출)가 같은 길이를 가짐
- 비슷한 추상화 계층에 있는 함수들만 호출
- 서로 다른 구체화 단계의 기능을 혼재하지 않음

</details>

## 퀴즈 2: 코드 분석

**다음 코드에서 직접 구현 패턴을 위반하는 부분을 찾고, 어떻게 개선할 수 있는지 설명하세요.**

javascript

```javascript
function processOrder(cart) {
    var total = 0;
    // 직접 반복문으로 합계 계산
    for (var i = 0; i < cart.length; i++) {
        total += cart[i].price;
    }
    
    // 비즈니스 로직: 100달러 이상이면 10% 할인
    if (total >= 100) {
        total = total * 0.9;
    }
    
    return total;
}
```

<details> <summary>답안 보기</summary>

**위반 부분**:

- `processOrder` 함수가 저수준의 반복문과 고수준의 비즈니스 로직을 동시에 처리
- 서로 다른 구체화 단계의 작업을 한 함수에서 수행

**개선 방안**:

javascript

```javascript
function processOrder(cart) {
    var total = calculateTotal(cart);
    return applyDiscount(total);
}

function calculateTotal(cart) {
    var total = 0;
    for (var i = 0; i < cart.length; i++) {
        total += cart[i].price;
    }
    return total;
}

function applyDiscount(total) {
    if (total >= 100) {
        return total * 0.9;
    }
    return total;
}
```

</details>

## 퀴즈 3: 계층 구조 설계

**장바구니 시스템에서 다음 함수들을 적절한 계층으로 분류하고, 그 이유를 설명하세요.**

함수 목록:

- `addPromotionalItem()` - 특정 마케팅 캠페인으로 상품 추가
- `addItem()` - 장바구니에 상품 추가
- `arrayPush()` - 배열에 요소 추가
- `calculateShipping()` - 배송비 계산
- `for loop` - 언어 기본 기능

<details> <summary>답안 보기</summary>

**계층 구조 (위에서 아래로)**:

1. **최상위 계층**: `addPromotionalItem()`
    - 특정 비즈니스 로직/마케팅 캠페인 관련
2. **비즈니스 로직 계층**: `calculateShipping()`
    - 도메인 특화 계산 로직
3. **장바구니 도메인 계층**: `addItem()`
    - 장바구니라는 도메인 개념의 기본 동작
4. **배열 유틸리티 계층**: `arrayPush()`
    - 일반적인 배열 조작 함수
5. **언어 기능 계층**: `for loop`
    - 프로그래밍 언어에서 제공하는 기본 기능

**이유**: 더 구체적이고 특화된 기능일수록 위쪽 계층에, 더 일반적이고 범용적인 기능일수록 아래쪽 계층에 위치합니다.

</details>

## 퀴즈 4: 응용 문제

**텍스트에서 언급된 `isInCart()`와 `indexOfItem()` 함수의 관계를 보고, 다음 중 올바른 설명을 고르세요.**

A) `isInCart()`가 더 낮은 수준의 함수이므로 `indexOfItem()`을 호출해야 한다 B) `indexOfItem()`이 더 낮은 수준의 함수이므로 `isInCart()`가 `indexOfItem()`을 호출해야 한다 C) 두 함수는 같은 수준이므로 서로 호출하면 안 된다 D) 두 함수는 독립적이므로 관계가 없다

<details> <summary>답안 보기</summary>

**정답: B**

**이유**:

- `indexOfItem()`은 배열의 인덱스를 반환하므로, 사용하는 곳에서 장바구니가 배열이라는 구체적인 구조를 알아야 합니다.
- `isInCart()`은 불리언 값을 반환하므로, 사용하는 곳에서 장바구니의 내부 구조를 몰라도 됩니다.
- 따라서 `indexOfItem()`이 더 낮은 수준의 함수이고, `isInCart()`가 `indexOfItem()`을 호출하는 것이 적절합니다.

실제 구현:

javascript

```js
function isInCart(cart, name) {
    return indexOfItem(cart, name) !== null;
}
```

</details>



## CHAPTER 9

## 📌 요약 정리

### 1. **계층형 설계 패턴의 목적**

- 코드를 모듈화하고, 적절한 추상화 수준을 유지하여 유지보수, 테스트, 재사용에 유리하게 만드는 설계 기법.
    

---

### 2. **4가지 계층형 설계 패턴**

#### 📍패턴 1: 직접 구현

- 함수는 문제를 명확히 나타내는 시그니처를 가져야 하며, 그 본문은 _적절한 수준의 구체화_로 문제를 해결해야 한다.
    
- 함수가 너무 구체적이면 **나쁜 냄새**.
    

#### 📍패턴 2: 추상화 벽 (`abstraction barrier`)

- 내부 구현을 감추는 인터페이스를 정의하여 **계층 간 독립성** 확보.
    
- 하위 구현이 바뀌어도 상위 계층은 영향을 받지 않음.
    
- 예: 장바구니 데이터 구조를 배열 → 해시맵으로 변경하더라도 추상화 벽 위 함수는 수정할 필요 없음.
    

#### 📍패턴 3: 작은 인터페이스 (`minimal interface`)

- 추상화 벽에 너무 많은 기능을 넣지 말고, 최소한의 강력한 함수만 정의.
    
- 새로운 기능은 상위 계층에서 구현하여 하위 계층의 변경을 최소화.
    
- 마케팅 로직을 하위 계층에 넣으면 하위 계층이 커지고 테스트 어려움 증가.
    

#### 📍패턴 4: 편리한 계층 (`convenient layer`)

- 설계는 필요할 때만. 코드가 **불편하거나 지저분**하다고 느껴질 때 다시 설계 적용.
    
- 너무 과한 설계는 피하고, **필요할 때만 계층 추가**.
    

---

### 3. **호출 그래프가 알려주는 비기능 요구사항**

|항목|규칙/핵심 개념|
|---|---|
|**유지보수성**|위로 연결된 함수가 적으면 바꾸기 쉽다. 자주 바뀌는 코드는 위쪽에 있어야 한다.|
|**테스트성**|아래쪽(핵심)에 있는 함수는 자주 바뀌지 않으므로 테스트 가치가 높다.|
|**재사용성**|아래쪽 계층에 있는 함수일수록 재사용에 좋다. 낮은 수준일수록 더 보편적이다.|

---

## 🧠 퀴즈 타임

### ❓1. 직접 구현 패턴에서 함수 본문이 너무 구체적일 때 나타나는 현상은 무엇인가요?

a) 유지보수성이 향상된다  
b) 테스트가 쉬워진다  
c) 코드에서 냄새가 난다  
d) 추상화 수준이 높아진다

<details><summary>정답 보기</summary> c) 코드에서 냄새가 난다 </details>

---

### ❓2. 추상화 벽을 사용하는 이유는 무엇인가요?

a) 하위 계층에 더 많은 기능을 추가하기 위해  
b) 코드에 액션을 직접 넣기 위해  
c) 세부 구현을 감추고 계층 간 독립성을 확보하기 위해  
d) 성능 최적화를 위해

<details><summary>정답 보기</summary> c) 세부 구현을 감추고 계층 간 독립성을 확보하기 위해 </details>

---

### ❓3. 마케팅팀의 요구로 장바구니 로그를 남길 때, `add_item()` 함수에서 로그를 남기지 않아야 하는 이유는?

a) 로그를 남기면 기능이 동작하지 않는다  
b) `add_item()`은 추상화 벽 위에 있어야 하므로  
c) `add_item()`은 순수 함수이며 액션을 포함시키면 테스트가 어려워지기 때문  
d) 로그는 하위 계층에서 처리해야 하기 때문

<details><summary>정답 보기</summary> c) `add_item()`은 순수 함수이며 액션을 포함시키면 테스트가 어려워지기 때문 </details>

---

### ❓4. 아래 중 **작은 인터페이스 패턴**의 이점이 아닌 것은?

a) 하위 계층에 코드가 많아진다  
b) 구현 변경 시 수정 범위가 작다  
c) 버그 발생 가능성이 줄어든다  
d) 팀 간 조율 비용이 줄어든다

<details><summary>정답 보기</summary> a) 하위 계층에 코드가 많아진다 </details>

---

### ❓5. 호출 그래프에서 가장 위에 있는 코드는 어떤 특징을 갖고 있나요?

a) 자주 바뀌지 않는다  
b) 테스트할 필요가 없다  
c) 바꾸기 어렵다  
d) 바꾸기 쉽다

<details><summary>정답 보기</summary> d) 바꾸기 쉽다 </details>